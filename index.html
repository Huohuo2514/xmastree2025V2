<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grand Luxury Interactive Christmas Tree</title>
    
    <!-- CSS Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <!-- Babel for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        background-color: #020f08; /* Very dark emerald */
        overflow: hidden;
        font-family: 'Playfair Display', serif;
      }
      canvas {
        touch-action: none;
      }
      /* Custom scrollbar for webkit */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #020f08; 
      }
      ::-webkit-scrollbar-thumb {
        background: #D4AF37; 
        border-radius: 4px;
      }
    </style>

    <!-- Import Map -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "zustand": "https://esm.sh/zustand@4.5.0?external=react",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.8",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useMemo, useLayoutEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame } from '@react-three/fiber';
      import { Environment, OrbitControls, PerspectiveCamera } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
      import { create } from 'zustand';
      import { GestureRecognizer, FilesetResolver } from '@mediapipe/tasks-vision';

      // --- Types (Simulated as Constants for JS) ---
      const AppState = {
        FORMED: 'FORMED',
        CHAOS: 'CHAOS',
      };

      // --- Store ---
      const useAppStore = create((set) => ({
        appState: AppState.FORMED,
        setAppState: (appState) => set({ appState }),
        
        visionState: {
          gesture: 'None',
          handPosition: { x: 0.5, y: 0.5 },
          isTracking: false,
        },
        setVisionState: (newState) => set((state) => ({ 
          visionState: { ...state.visionState, ...newState } 
        })),

        progress: 1,
        setProgress: (progress) => set({ progress }),
      }));

      // --- Helpers ---
      const getTreePosition = (ratio, radiusBase, height, yOffset) => {
        const h = height;
        const y = Math.random() * h;
        const rAtY = radiusBase * (1 - y / h);
        const theta = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * rAtY; 
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        
        return new THREE.Vector3(x, y + yOffset, z);
      };

      const getChaosPosition = (radius) => {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phiVal = THREE.MathUtils.clamp(2 * v - 1, -1, 1);
        const phi = Math.acos(phiVal);
        const r = radius * Math.cbrt(Math.random());
        
        const sinPhi = Math.sin(phi);
        return new THREE.Vector3(
          r * sinPhi * Math.cos(theta),
          r * sinPhi * Math.sin(theta),
          r * Math.cos(phi)
        );
      };

      // --- Components ---

      // 1. Foliage
      const vertexShader = `
        uniform float uProgress;
        uniform float uTime;
        attribute vec3 chaosPos;
        attribute vec3 targetPos;
        attribute float aSize;
        attribute vec3 aColor;
        
        varying vec3 vColor;
        
        float easeOutCubic(float x) {
          return 1.0 - pow(1.0 - x, 3.0);
        }

        void main() {
          vColor = aColor;
          float noise = sin(chaosPos.y * 0.5 + uTime) * (1.0 - uProgress);
          vec3 currentPos = mix(chaosPos, targetPos, easeOutCubic(uProgress));
          
          if (uProgress > 0.95) {
             currentPos.x += sin(uTime * 2.0 + currentPos.y) * 0.05;
             currentPos.z += cos(uTime * 1.5 + currentPos.y) * 0.05;
          }

          vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
          gl_PointSize = aSize * (200.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        varying vec3 vColor;
        
        void main() {
          float r = distance(gl_PointCoord, vec2(0.5));
          if (r > 0.5) discard;
          
          float glow = 1.0 - (r * 2.0);
          glow = pow(glow, 1.5);
          
          gl_FragColor = vec4(vColor, 1.0) * glow;
        }
      `;

      const Foliage = ({ count, height, radius }) => {
        const meshRef = useRef(null);
        const shaderRef = useRef(null);
        const progress = useAppStore(state => state.progress);

        const { positions, chaosPositions, colors, sizes } = useMemo(() => {
          const positions = new Float32Array(count * 3);
          const chaosPositions = new Float32Array(count * 3);
          const colors = new Float32Array(count * 3);
          const sizes = new Float32Array(count);

          const emerald = new THREE.Color("#05472A");
          const gold = new THREE.Color("#D4AF37");
          const lightGold = new THREE.Color("#FFF8C0");

          for (let i = 0; i < count; i++) {
            const target = getTreePosition(Math.random(), radius, height, 1);
            positions[i * 3] = target.x;
            positions[i * 3 + 1] = target.y;
            positions[i * 3 + 2] = target.z;

            const chaos = getChaosPosition(25);
            chaosPositions[i * 3] = chaos.x;
            chaosPositions[i * 3 + 1] = chaos.y;
            chaosPositions[i * 3 + 2] = chaos.z;

            const isGold = Math.random() > 0.8;
            const col = isGold ? (Math.random() > 0.5 ? gold : lightGold) : emerald;
            
            if (!isGold) {
               col.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1); 
            }
            
            colors[i * 3] = col.r;
            colors[i * 3 + 1] = col.g;
            colors[i * 3 + 2] = col.b;

            sizes[i] = Math.random() * 0.5 + 0.2;
          }

          return { positions, chaosPositions, colors, sizes };
        }, [count, height, radius]);

        useFrame((state) => {
          if (shaderRef.current) {
            shaderRef.current.uniforms.uTime.value = state.clock.elapsedTime;
            shaderRef.current.uniforms.uProgress.value = progress;
          }
        });

        return (
          <points ref={meshRef}>
            <bufferGeometry>
              <bufferAttribute attach="attributes-targetPos" count={count} array={positions} itemSize={3} />
              <bufferAttribute attach="attributes-position" count={count} array={chaosPositions} itemSize={3} />
              <bufferAttribute attach="attributes-chaosPos" count={count} array={chaosPositions} itemSize={3} />
              <bufferAttribute attach="attributes-aColor" count={count} array={colors} itemSize={3} />
              <bufferAttribute attach="attributes-aSize" count={count} array={sizes} itemSize={1} />
            </bufferGeometry>
            <shaderMaterial
              ref={shaderRef}
              vertexShader={vertexShader}
              fragmentShader={fragmentShader}
              uniforms={{
                uTime: { value: 0 },
                uProgress: { value: 1 },
              }}
              transparent
              depthWrite={false}
              blending={THREE.AdditiveBlending}
            />
          </points>
        );
      };

      // 2. Ornaments
      const Ornaments = ({ count, height, radius }) => {
        const meshRef = useRef(null);
        const progress = useAppStore(state => state.progress);

        const { data } = useMemo(() => {
          const temp = [];
          for (let i = 0; i < count; i++) {
            const h = height;
            const y = Math.random() * h;
            const rAtY = radius * (1 - y / h);
            const theta = Math.random() * Math.PI * 2;
            const x = rAtY * Math.cos(theta);
            const z = rAtY * Math.sin(theta);
            const targetPos = new THREE.Vector3(x, y + 1, z);

            const chaosPos = getChaosPosition(30);
            const scale = Math.random() * 0.4 + 0.2;
            const rotation = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0);

            const color = new THREE.Color();
            const type = Math.random();
            if (type > 0.6) color.setHex(0xD4AF37);
            else if (type > 0.3) color.setHex(0xAA0000);
            else color.setHex(0xC0C0C0);

            temp.push({ targetPos, chaosPos, scale, rotation, color });
          }
          return { data: temp };
        }, [count, height, radius]);

        useLayoutEffect(() => {
          if (!meshRef.current) return;
          for (let i = 0; i < count; i++) {
            meshRef.current.setColorAt(i, data[i].color);
          }
          if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
        }, [data, count]);

        const dummy = useMemo(() => new THREE.Object3D(), []);

        useFrame((state) => {
          if (!meshRef.current) return;
          
          for (let i = 0; i < count; i++) {
            const { targetPos, chaosPos, scale, rotation } = data[i];
            const stagger = i * 0.0005; 
            let p = THREE.MathUtils.clamp(progress + (progress > 0.5 ? stagger : -stagger), 0, 1);
            p = 1 - Math.pow(1 - p, 3);

            dummy.position.lerpVectors(chaosPos, targetPos, p);
            dummy.rotation.set(
              rotation.x + state.clock.elapsedTime * (1-p), 
              rotation.y + state.clock.elapsedTime * (1-p), 
              rotation.z
            );
            dummy.scale.setScalar(scale);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          }
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, count]} castShadow receiveShadow>
            <sphereGeometry args={[1, 16, 16]} />
            <meshStandardMaterial roughness={0.1} metalness={0.9} envMapIntensity={2} />
          </instancedMesh>
        );
      };

      // 3. Polaroids
      const Polaroids = ({ count, height, radius }) => {
        const meshRef = useRef(null);
        const progress = useAppStore(state => state.progress);
        
        const { data } = useMemo(() => {
          const temp = [];
          for (let i = 0; i < count; i++) {
             const t = i / count;
             const y = height * (1 - t) + 1;
             const rCurrent = radius * (1 - y/height) + 1.5; 
             const angle = t * Math.PI * 10; 
             
             const targetPos = new THREE.Vector3(
               Math.cos(angle) * rCurrent,
               y,
               Math.sin(angle) * rCurrent
             );
             
             const chaosPos = getChaosPosition(35);
             const lookAt = new THREE.Vector3(targetPos.x * 2, targetPos.y, targetPos.z * 2);
             
             temp.push({ targetPos, chaosPos, lookAt });
          }
          return { data: temp };
        }, [count, height, radius]);

        const dummy = useMemo(() => new THREE.Object3D(), []);

        useFrame(() => {
          if (!meshRef.current) return;
          
          for (let i = 0; i < count; i++) {
              const { targetPos, chaosPos, lookAt } = data[i];
              const stagger = i * 0.002;
              let p = THREE.MathUtils.clamp(progress + (progress > 0.5 ? stagger : -stagger), 0, 1);
              p = 1 - Math.pow(1 - p, 4); 
              
              dummy.position.lerpVectors(chaosPos, targetPos, p);
              dummy.lookAt(lookAt);
              if (p < 0.9) {
                  dummy.rotateZ((1-p) * 2);
                  dummy.rotateX((1-p));
              }
              
              dummy.scale.setScalar(1.5);
              dummy.updateMatrix();
              meshRef.current.setMatrixAt(i, dummy.matrix);
          }
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, count]}>
            <boxGeometry args={[0.8, 1.0, 0.05]} />
            <meshStandardMaterial color="#fff" roughness={0.5} metalness={0.1} />
          </instancedMesh>
        );
      };

      // 4. ChristmasTree (Container)
      const ChristmasTree = () => {
        const TREE_HEIGHT = 18;
        const TREE_RADIUS = 7;
        const PARTICLE_COUNT = 6000;
        const ORNAMENT_COUNT = 300;
        const POLAROID_COUNT = 40;

        return (
          <group>
              <mesh position={[0, 0, 0]} receiveShadow>
                  <cylinderGeometry args={[2, 2.5, 1, 32]} />
                  <meshStandardMaterial color="#D4AF37" metalness={1} roughness={0.1} />
              </mesh>
              <Foliage count={PARTICLE_COUNT} height={TREE_HEIGHT} radius={TREE_RADIUS} />
              <Ornaments count={ORNAMENT_COUNT} height={TREE_HEIGHT} radius={TREE_RADIUS} />
              <Polaroids count={POLAROID_COUNT} height={TREE_HEIGHT} radius={TREE_RADIUS} />
          </group>
        );
      };

      // 5. VisionControl
      const VisionControl = () => {
        const videoRef = useRef(null);
        const { setAppState, setVisionState } = useAppStore();
        const [modelLoaded, setModelLoaded] = useState(false);
        const [error, setError] = useState(null);
        const requestRef = useRef(null);
        const gestureRecognizerRef = useRef(null);

        useEffect(() => {
          let isMounted = true;
          const initVision = async () => {
            try {
              const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
              );

              if (!isMounted) return;

              gestureRecognizerRef.current = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                  modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                  delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
              });
              
              if (isMounted) setModelLoaded(true);
            } catch (err) {
              console.error("Vision Init Error:", err);
              if (isMounted) setError("Gesture control unavailable. Use Mouse.");
            }
          };

          initVision();
          return () => { isMounted = false; };
        }, []);

        useEffect(() => {
          if (!modelLoaded || !videoRef.current) return;
          const startWebcam = async () => {
              try {
                  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                  if (videoRef.current) {
                      videoRef.current.srcObject = stream;
                  }
              } catch (err) {
                  console.error(err);
                  setError("Camera access denied.");
              }
          };
          startWebcam();
        }, [modelLoaded]);

        const predict = () => {
          if (!gestureRecognizerRef.current || !videoRef.current) return;
          if (videoRef.current.readyState >= 2) {
              try {
                  const results = gestureRecognizerRef.current.recognizeForVideo(videoRef.current, Date.now());
                  if (results.gestures.length > 0) {
                      const categoryName = results.gestures[0][0].categoryName;
                      const landmarks = results.landmarks[0]; 
                      const palmX = 1.0 - landmarks[0].x; 
                      const palmY = landmarks[0].y;

                      let newState = AppState.FORMED;
                      if (categoryName === "Open_Palm" || categoryName === "Victory") {
                          newState = AppState.CHAOS;
                      } else {
                          newState = AppState.FORMED;
                      }

                      setAppState(newState);
                      setVisionState({
                          gesture: categoryName,
                          handPosition: { x: palmX, y: palmY },
                          isTracking: true
                      });
                  } else {
                      setVisionState({ gesture: 'None', isTracking: false });
                      setAppState(AppState.FORMED);
                  }
              } catch (e) {
                  // Ignore transient errors
              }
          }
          requestRef.current = requestAnimationFrame(predict);
        };

        useEffect(() => {
            if (modelLoaded && videoRef.current) {
                if (requestRef.current) cancelAnimationFrame(requestRef.current);
                requestRef.current = requestAnimationFrame(predict);
            }
            return () => {
                if (requestRef.current) cancelAnimationFrame(requestRef.current);
            };
        }, [modelLoaded]);

        return (
          <div className="absolute top-4 right-4 w-48 h-36 z-50 border-2 border-[#D4AF37] rounded-lg overflow-hidden bg-black shadow-[0_0_20px_rgba(212,175,55,0.3)]">
              <video 
                  ref={videoRef} 
                  autoPlay 
                  playsInline
                  muted
                  className="w-full h-full object-cover transform -scale-x-100 opacity-80"
              />
              <div className="absolute bottom-0 w-full bg-black/60 text-[#D4AF37] text-[10px] text-center p-1 font-serif">
                  {error ? error : modelLoaded ? "CAMERA ACTIVE" : "LOADING AI..."}
              </div>
          </div>
        );
      };

      // 6. Overlay
      const Overlay = () => {
        const { appState, visionState } = useAppStore();
        const isChaos = appState === AppState.CHAOS;

        return (
          <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-12">
            <header className="text-center">
              <h1 className="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-b from-[#FFF] to-[#D4AF37] drop-shadow-[0_4px_10px_rgba(212,175,55,0.5)] font-serif tracking-widest">
                GRAND LUXURY
              </h1>
              <h2 className="text-xl md:text-2xl text-[#00ff88] mt-2 tracking-[0.5em] uppercase font-light border-b border-[#00ff88]/30 inline-block pb-2">
                Interactive Holiday Experience
              </h2>
            </header>
            <div className="flex flex-col items-center justify-center space-y-4">
              <div className={`transition-all duration-700 transform ${isChaos ? 'scale-110' : 'scale-100'}`}>
                   <p className={`text-4xl font-serif italic ${isChaos ? 'text-red-500 drop-shadow-[0_0_15px_red]' : 'text-[#D4AF37] drop-shadow-[0_0_15px_gold]'}`}>
                      {isChaos ? "UNLEASHED" : "MAGNIFICENCE"}
                   </p>
              </div>
              <div className="bg-black/40 backdrop-blur-md border border-[#D4AF37]/50 p-6 rounded-none max-w-md text-center">
                  <p className="text-[#D4AF37] text-sm uppercase tracking-widest mb-2 border-b border-[#D4AF37]/30 pb-2">
                      Controls
                  </p>
                  <div className="text-white/80 space-y-2 font-serif">
                      <p><span className="text-[#D4AF37] font-bold">Open Hand:</span> Unleash Chaos</p>
                      <p><span className="text-[#D4AF37] font-bold">Closed Hand:</span> Restore Form</p>
                      <p><span className="text-[#D4AF37] font-bold">Move Hand:</span> Adjust Perspective</p>
                  </div>
                  {visionState.isTracking && (
                      <div className="mt-4 text-xs text-green-400 animate-pulse">
                          AI TRACKING: {visionState.gesture} detected
                      </div>
                  )}
              </div>
            </div>
            <footer className="text-center text-[#D4AF37]/60 text-xs tracking-widest uppercase">
               The Grand Christmas Collection â€¢ {new Date().getFullYear()}
            </footer>
          </div>
        );
      };

      // 7. Experience
      const Experience = () => {
        const { appState, progress, setProgress, visionState } = useAppStore();
        const orbitRef = useRef(null);

        useFrame((state, delta) => {
          const targetProgress = appState === AppState.FORMED ? 1 : 0;
          const newProgress = THREE.MathUtils.lerp(progress, targetProgress, delta * 2.5);
          setProgress(newProgress);

          if (visionState.isTracking && orbitRef.current) {
              const targetAzimuth = (visionState.handPosition.x - 0.5) * 2; 
              const cam = state.camera;
              cam.position.x = THREE.MathUtils.lerp(cam.position.x, targetAzimuth * 10, delta);
              cam.position.y = THREE.MathUtils.lerp(cam.position.y, 4 - (visionState.handPosition.y - 0.5) * 5, delta);
              cam.lookAt(0, 4, 0);
          }
        });

        return (
          <React.Fragment>
            <PerspectiveCamera makeDefault position={[0, 4, 24]} />
            <Environment 
              files="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/st_fagans_interior_1k.hdr" 
              background={false} 
            />
            <ambientLight intensity={0.2} color="#004020" />
            <spotLight 
              position={[10, 20, 10]} 
              angle={0.5} 
              penumbra={1} 
              intensity={2} 
              color="#ffeebb" 
              castShadow 
            />
            <pointLight position={[-10, 10, -10]} intensity={1} color="#00ff88" />

            <OrbitControls 
              ref={orbitRef}
              enableZoom={true} 
              enablePan={false}
              maxPolarAngle={Math.PI / 1.5}
              minPolarAngle={Math.PI / 3}
              enabled={!visionState.isTracking} 
            />

            <group position={[0, -5, 0]}>
              <ChristmasTree />
            </group>

            <EffectComposer enableNormalPass={false}>
              <Bloom luminanceThreshold={0.8} mipmapBlur intensity={1.5} radius={0.6} />
              <Vignette eskil={false} offset={0.1} darkness={1.1} />
            </EffectComposer>
          </React.Fragment>
        );
      };

      // 8. App & Entry Point
      const App = () => {
        return (
          <div className="relative w-full h-screen bg-gradient-to-b from-[#020f08] to-[#001a10]">
            <Canvas
              shadows
              camera={{ position: [0, 4, 20], fov: 45 }}
              gl={{ antialias: false, powerPreference: "high-performance" }}
              dpr={[1, 2]}
            >
              <Experience />
            </Canvas>
            <VisionControl />
            <Overlay />
            <div className="absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_center,transparent_0%,#000000_120%)] opacity-80" />
          </div>
        );
      };

      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
      }
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>